# JVM调优-GC篇

[TOC]

## 一、什么是垃圾回收？

程序的运行必然需要申请内存资源，无效的对象资源如果不及时处理就会一直占有内存资源，最终将导致内存溢出，所以对内存资源的管理是非常重要了，对无效对象的内存回收就叫做垃圾回收。

### 1、c/c++语言中的垃圾回收

在C/C++语言中，没有自动垃圾回收机制，是通过new关键字申请内存资源，通过delete关键字释放内存资源。

如果，程序员在某些位置没有写delete进行释放，那么申请的对象将一直占用内存资源，最终可能会导致内存溢出 。

### 2、java语言中的垃圾回收

为了让程序员更专注于代码的实现，而不用过多的考虑内存释放的问题，所以，在Java语言中，有了自动的垃圾回收机制，也就是我们熟悉的GC。

有了垃圾回收机制后，程序员只需要关心内存的申请即可，内存的释放由系统自动识别完成。

换句话说，自动的垃圾回收的算法就会变得非常重要了，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。

当然，除了Java语言，C#、Python等语言也都有自动的垃圾回收机制。

## 二、垃圾回收的常见算法

自动化的管理内存资源，垃圾回收机制必须要有一套算法来进行计算，哪些是有效的对象，哪些是无效的对象，对于无效的对象就要进行回收处理。

常见的垃圾回收算法有：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。 

### 1、引用计数法

引用计数是历史最悠久的一种算法，最早George E. Collins在1960的时候首次提出，60年后的今天，该算法依然被很多编程语言使用。

**1）、原理**

假设有一个对象A，任何一个对象对A的引用，那么对象A的 引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收。

**2）、优缺点**

优点：

* 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。
* 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报outofmemory 错误。
* 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。

缺点：

* 每次对象被引用时，都需要去更新计数器，有一点时间开销。
* 浪费CPU资源，即使内存够用，仍然在运行时进行计数器的统计。
* 无法解决循环引用问题。（最大的缺点）



什么是循环引用？

![1590300681893](https://smartan123.github.io/book/library/002-images/1590300681893.png)

**具体讲解请观看视频**



### 2、标记清除法

标记清除算法是将垃圾回收分为2个阶段，分别是标记和清除。

标记：从根节点开始标记引用的对象

清除：未被标记引用的对象就是垃圾对象，可以被清理

**1）、原理**

![1590300826193](https://smartan123.github.io/book/library/002-images/1590300826193.png)



上面这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示 ：

 ![1590300926143](https://smartan123.github.io/book/library/002-images/1590300926143.png)

可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。

 

**2）、优缺点**

优点：

* 标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。

缺点：

* 效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。
* 通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。



### 3、标记压缩法

标记压缩算法是在标记清除算法的基础之上，做了优化改进的算法。和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的清理未标记的对象，而是将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。

**1）、原理**

![1590301249595](https://smartan123.github.io/book/library/002-images/1590301249595.png)



**2）、优缺点**

优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有一定的影响。



### 4、复制算法

复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。

如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。

**1）、原理**

![1590301371613](https://smartan123.github.io/book/library/002-images/1590301371613.png)

**具体分析讲解见视频**



**2）、JVM中年轻代内存空间**

![1590301470052](https://smartan123.github.io/book/library/002-images/1590301470052.png)

* 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
* 紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。
* 经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。
* GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 



**3）、优缺点**

优点：

* 在垃圾对象多的情况下，效率较高 。
* 清理后，内存无碎片。

缺点：

* 在垃圾对象少的情况下，不适用，如：老年代内存。
* 分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低



### 5、分代算法

前面介绍了多种回收算法，每一种算法都有自己的优点也有缺点，谁都不能替代谁，所以根据垃圾回收对象的特点进行选择，才是明智的选择。

分代算法其实就是这样的，根据回收对象的特点进行选择，在jvm中，年轻代适合使用复制算法，老年代适合使用标记清除或标记压缩算法。



## 三、垃圾收集器及内存分配

前面我们讲了垃圾回收的算法，还需要有具体的实现，在jvm中，实现了多种垃圾收集器，包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器，接下来，我们一个个的了解学习。

**垃圾收集器种类**

![1590301827427](https://smartan123.github.io/book/library/002-images/1590301827427.png)



**HotSpot虚拟机所包含的收集器**

![1590301854328](https://smartan123.github.io/book/library/002-images/1590301854328.png)



**垃圾收集器部分源码**

![1590301881521](https://smartan123.github.io/book/library/002-images/1590301881521.png)



**垃圾收集器后台日志参数说明与配对关系**

* DefNew - Default New Generation
* Tenured - Old
* ParNew - Parallel New Generation
* PSYoungGen - Parallel Scavenge
* ParOldGen - Parallel Old Generation

**以上不同种类，已经回收器的配对使用分析讲解见视频**



### 1、串行垃圾收集器

串行垃圾收集器是最基本的、发展历史最悠久的收集器。

特点：单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。

**串行垃圾收集器运行示意图**

![1590302084563](https://smartan123.github.io/book/library/002-images/1590302084563.png)

**串行垃圾收集器原理分析见视频**



**1）、编写测试代码**

思路：while循环中不断拼接字符串，直到oom异常，查看gc情况

~~~java
import java.util.UUID;

/**************************************************
 *
 * @title
 * @desc ling
 * @author smart哥
 *
 **************************************************/
public class TestGC1 {
	/**
	 * java -XX:+PrintCommandLineFlags -version
	 *
	 * @param args
	 */
	public static void main(String[] args) {
		String str = "smart哥";
		while (true) {
			str += str + UUID.randomUUID();
			str.intern();
		}
	}
}
~~~



**2）、设置垃圾回收为串行收集器** 

在程序运行参数中添加2个参数，如下：

 -XX:+UseSerialGC
 指定年轻代和老年代都使用串行垃圾收集器

 -XX:+PrintGCDetails
 打印垃圾回收的详细信息



**3）、启动程序，GC日志信息解读**

![1590302432800](https://smartan123.github.io/book/library/002-images/1590302432800.png)

**具体解读请观看视频**



### 2、并行垃圾收集器

并行垃圾收集器在串行垃圾收集器的基础之上做了改进，将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。（这里是指，并行能力较强的机器）

当然了，并行垃圾收集器在收集的过程中也会暂停应用程序，这个和串行垃圾回收器是一样的，只是并行执行，速度更快些，暂停的时间更短一些。

**并行垃圾收集器-ParNew运行示意图**

![1590302579723](https://smartan123.github.io/book/library/002-images/1590302579723.png)

ParNew垃圾收集器

通过-XX:+UseParNewGC参数设置年轻代使用ParNew回收器，老年代使用的依然是串行收集器

通过-XX:+ParallelGCThreads可以限制GC线程数量，默认开启和cpu数目相同的线程数

**具体讲解见视频**

**1）、编写测试代码**

同之前的代码



**2）、设置垃圾回收为并行收集器ParNew**

在程序运行参数中添加1个参数，如下

-XX:+UseParNewGC



**3）、启动程序，GC日志信息解读**

![1590302860478](https://smartan123.github.io/book/library/002-images/1590302860478.png)

**具体解读请观看视频**



**并行垃圾收集器-ParallelGC运行示意图**

![1590302913513](https://smartan123.github.io/book/library/002-images/1590302913513.png)



ParallelGC垃圾收集器

ParallelGC收集器工作机制和ParNewGC收集器一样，只是在此基础之上，新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。

**具体讲解见视频**

**1）、编写测试代码**

同之前的代码



**2）、设置垃圾回收为并行收集器ParallelGC**

ParallelGC垃圾收集器相关参数如下：

-XX:+UseParallelGC 
-XX:+UseParallelOldGC 
-XX:MaxGCPauseMillis 
-XX:ParallelGCThreads=N



**3）、启动程序，GC日志信息解读**

![1590303148247](https://smartan123.github.io/book/library/002-images/1590303148247.png)

**具体解读见视频**



### 3、CMS垃圾收集器

CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，通过参数-XX:+UseConcMarkSweepGC进行设置。

**CMS垃圾收集器运行示意图**：

![1590303242254](https://smartan123.github.io/book/library/002-images/1590303242254.png)

**示意图原理讲解见视频**

**CMS垃圾回收器的执行过程如下：**

![1590303288641](https://smartan123.github.io/book/library/002-images/1590303288641.png)

**执行过程具体讲解见视频**

**1）、编写测试代码**

同之前的代码



**2）、设置CMS垃圾回收参数**

-‐XX:+UseConcMarkSweepGC

注意：开启后将采用ParNew+CMS+Serial Old收集器组合



**3）、启动程序，GC日志信息解读**

![1590303375232](https://smartan123.github.io/book/library/002-images/1590303375232.png)

**具体解读见视频**



### 4、G1垃圾收集器

G1垃圾收集器是在jdk1.7update4中正式使用的全新的垃圾收集器，oracle官方在jdk9中将G1变成默认的垃圾收集器，以替代CMS。

G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：

* 第一步，开启G1垃圾收集器
* 第二步，设置堆的最大内存
* 第三步，设置最大的停顿时间
  * G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。



G1垃圾收集器相对比其他收集器而言，最大的区别在于它取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了有逻辑上的年轻代、老年代区域。这样做的好处就是，我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。 

**G1垃圾收集器(将新生代，老年代的物理空间划分取消了)，示意图如下**

![1590303602771](https://smartan123.github.io/book/library/002-images/1590303602771.png)

**G1垃圾收集器(G1算法将堆划分为若干个区域-Region)**

![1590303631684](https://smartan123.github.io/book/library/002-images/1590303631684.png)

**G1垃圾收集器原理**

![1590303683132](https://smartan123.github.io/book/library/002-images/1590303683132.png)

![1590303692110](https://smartan123.github.io/book/library/002-images/1590303692110.png)

在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。

这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。

在G1中，有一种特殊的区域，叫Humongous区域。如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。

这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。

为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。

针对Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。

Survivor区的数据移动到新Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。  



**G1垃圾回收模式：Young GC**

![1590303868180](https://smartan123.github.io/book/library/002-images/1590303868180.png)

**具体模式讲解见视频**



**G1垃圾回收模式：Mixed GC**

分2步：

* 全局并发标记（global concurrent marking）
* 拷贝存活对象（evacuation）



**G1垃圾收集器运行示意图**

![1590303955056](https://smartan123.github.io/book/library/002-images/1590303955056.png)

**具体讲解见视频**

**1）、编写测试代码**

同之前的代码



**2）、设置G1垃圾回收参数**

‐XX:+PrintGC 输出GC日志
‐XX:+PrintGCDetails 输出GC的详细日志
‐XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
‐XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013‐05‐04T21:53:59.234+0800）
‐XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
‐Xloggc:F://test//gc.log 日志文件的输出路径



**3）、启动程序，GC日志信息解读**

![1590304335832](https://smartan123.github.io/book/library/002-images/1590304335832.png)



**G1垃圾收集器 vs CMS垃圾收集器**

* G1不会产生碎片
* G1可以精准控制停顿，它把整堆划分为多个固定大小的区域，每次根据停顿时间去收集垃圾最多的区域



**G1垃圾收集器优化建议**

* 年轻代大小
  * 避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小
  * 固定年轻代的大小会覆盖暂停时间目标 

* 暂停时间目标不要太过严苛
  * G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间 
  * 评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量



## 五、可视化GC日志分析工具

### 1、GC日志输出参数

前面通过-XX:+PrintGCDetails可以对GC日志进行打印，我们就可以在控制台查看，这样虽然可以查看GC的信息，但是并不直观，可以借助于第三方的GC日志分析工具进行查看。
在日志打印输出涉及到的参数如下： 

~~~shell
‐XX:+PrintGC 输出GC日志
‐XX:+PrintGCDetails 输出GC的详细日志
‐XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
‐XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013‐05‐
04T21:53:59.234+0800）
‐XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
‐Xloggc:../logs/gc.log 日志文件的输出路径
~~~

测试： 

~~~java
‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=100 ‐Xmx256m ‐XX:+PrintGCDetails ‐
XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐XX:+PrintHeapAtGC ‐
Xloggc:F://test//gc.log
~~~

最后生成gc.log,我们利用下面的可视化工具进行分析。

### 2、GC Easy可视化工具

GC Easy是一款在线的可视化工具，易用、功能强大， GCEasy官网地址：http://gceasy.io/ 

打开官网上传gc.log,点击分析即可。分析完之后它会给我们出相关的分析报告，那查看指标如何解读呢？

**具体解读见视频**

**GC Easy查看gc报告**

![1590304703407](https://smartan123.github.io/book/library/002-images/1590304703407.png)

![1590304748166](https://smartan123.github.io/book/library/002-images/1590304748166.png)

![1590304759459](https://smartan123.github.io/book/library/002-images/1590304759459.png)

![1590304768991](https://smartan123.github.io/book/library/002-images/1590304768991.png)

![1590304777129](https://smartan123.github.io/book/library/002-images/1590304777129.png)

**分析报告解读请观看视频**



## 六、本章小结

![1590304790493](https://smartan123.github.io/book/library/002-images/1590304790493.png)